\documentclass{article}
\usepackage{blogpost}
\usepackage{natbib}
\usepackage{xcolor}

\usepackage{minted}
\usemintedstyle{manni}
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\newcommand{\code}[1]{\texttt{#1}}

\usepackage{soul}
\sethlcolor{yellow}
\newcommand{\todo}[1]{\textbf{\hl{TODO: #1}}}

\newcommand{\St}{\text{St}}

\renewcommand{\vec}[1]{\textbf{#1}}


\title{Walk on Stars --- Implementation Guide}
\author{posted by Keenan}

\begin{document}

\maketitle

\begin{figure}[h!]
   \todo{Figure showing a polygonal domain $\Omega$, with the two boundary components drawn in different styles}
   \caption{The domain for our problem.\label{fig:ProblemDomain}}
\end{figure}

This note provides a step-by-step tutorial on how to implement the \emph{walk on stars (WoSt)} algorithm of \citet{Sawhney:2023:WoSt}.  Though the derivation of algorithm takes some work (as detailed in the paper), the final algorithm itself is quite easy to implement.  To put focus on the ``core'' ideas of the WoSt algorithm, we here describe a bare-bones 2D version that solves the Laplace equation
\[
   \begin{array}{rcll}
      \Delta u &=& 0 & \text{on}\ \Omega, \\
             u &=& g & \text{on}\ \partial\Omega_D, \\
             \tfrac{\partial u}{\partial n} &=& 0 & \text{on}\ \partial\Omega_N, \\
   \end{array}
\]
where \(\Omega \subset \mathbb{R}^2\) is a closed polygon in the plane, \(g\) is a real-valued function on the Dirichlet part of the boundary \(\partial\Omega_D\), and \(\partial\Omega_N\) is the complementary Neumann part of the boundary.  For simplicity, we also skip any acceleration of geometric queries.  Some pointers on how to the implement a more full-blown version of WoSt are provided near the end of the document.  Let's dive in!

\section{Overview}
\label{sec:Overview}

\subsection{Walk on Spheres (WoS)}
\label{sec:WalkonSpheresOverview}

A good place to start understanding WoSt is the simpler \emph{walk on spheres (WoS)} algorithm, which solves the same problem but with only Dirichlet boundary conditions (\ie, \(\partial_N = \emptyset\)).  The basic idea of WoS is really simple: to estimate the solution value at a point \(\vec{x}_0 \in \Omega\), you just take \(M\) random walks to the boundary \(\partial\Omega\) (for some large number \(M\)), and take the average value \(g\) at these boundary points.  That's it!  The reason it's called ``walk on \emph{spheres}'' is that you simulate these random walks by repeatedly jumping to the boundary of the largest empty sphere \(S_r(\vec{x}_k) \subset \Omega\) around the current point \(\vec{x}_k\) to get the next point \(\vec{x}_{k+1}\).  This way, steps tend to be big and you can quickly make progress toward the boundary (versus taking small, fixed-sized steps).  In a bit more detail, the WoS algorithm goes like this:

\begin{itemize}
   \item For \(i = 1, \ldots, M\):
\begin{itemize}
   \item Until \(\vec{x}_k\) is within a small distance \(\varepsilon\) of the domain boundary \(\partial\Omega\):
      \begin{itemize}
         \item Compute the distance \(r\) to the closest point \(\overline{\vec{x}}_k\) on \(\partial\Omega\).
         \item Pick a random point \(\vec{x}_{k+1}\) on the sphere \(S_r(\vec{x}_k)\) of radius \(r\) around \(\vec{x}_k\).
      \end{itemize}
   \item Add the value of \(g(\overline{\vec{x}}_k)\) to a running total \(\widehat{u}\).
\end{itemize}
   \item Return the estimate \(\widehat{u}/M\).
\end{itemize}

\begin{figure}
   \todo{A diagram showing a single walk with all the spheres on the left, another diagram in the center just showing the trajectories for a few walks, and a pseudocolor plot of the PDE solution (and boundary conditions) on the right.}
   \caption{\emph{Left:} an example walk taken by the WoS algorithm. \emph{Center:} the paths taken by a collection of walks. \emph{Right:} The final solution estimated by WoS.\label{fig:WoSExample}}
\end{figure}

Figure \ref{fig:WoSExample} shows an example.  To actually implement this algorithm, we really just need two kinds of subroutines:
\begin{itemize}
   \item \textbf{Geometric queries.}  For a given point \(\vec{x}_k \in \Omega\), we need to know how to compute the closest point \(\overline{\vec{x}}_k\) on the boundary.
   \item \textbf{Random sampling.} For a sphere \(S\) with center \(\vec{x}_k\) and radius \(r\), we need to know how to pick a point \(\vec{x}_{k+1}\) on \(S\) uniformly at random.
\end{itemize}

In fact, this basic structure will be the same for any ``walk on X'' algorithm (known more broadly as \emph{grid-free Monte Carlo methods}).  We generally need to perform some small set of geometric queries, and sample from some small set of probability distributions.  Otherwise, the logic is pretty similar: repeatedly apply these operations to simulate a random walk, and average values obtained from each walk to get the final solution estimate.

\subsection{Walk on Stars (WoSt)}
\label{sec:WalkOnStarsOverview}

\begin{figure}
   \todo{figure showing a region that is / is not star shaped relative to a point $\vec{x}$, and a ray from $\vec{x}$ in some direction $\vec{v}$ hitting the boundary} 
   \caption{A region \(R\) is \emph{star shaped} relative to a point \(\vec{x}\) if every point \(\vec{y} \in R\) is visible from \(\vec{x}\) along a straight line.  WoSt samples points on the boundary of a star shaped region by shooting a ray in a random direction \(\vec{v}\).\label{fig:StarShapedRegions}}
\end{figure}

The WoSt algorithm is almost like the WoS algorithm, except that it simulates random walks that ``reflect'' off the Neumann boundary \(\partial\Omega_N\), in addition to the walks already ``absorbed'' into the Dirichlet boundary \(\partial\Omega_D\).  To do so, WoSt makes just two small changes to WoS.  First, in place of spheres \(S(\vec{x})\), WoSt uses \emph{star-shaped regions} \(\St(\vec{x})\) (see Figure~\ref{fig:StarShapedRegions}).  Unlike the spheres used by WoS, which touch the boundary only at isolated points, the star-shaped regions used by WoSt can include large pieces of the Neumann boundary \(\partial\Omega_N\).  Second, rather than terminating walks at all boundaries, WoSt continues walking from any point on the Neumann part of the boundary \(\partial\Omega_N\).  The overall flow now goes like this:

\begin{itemize}
   \item For \(i = 1, \ldots, M\):
\begin{itemize}
   \item Until \(\vec{x}_k\) is within a small distance \(\varepsilon\) of the Dirichlet boundary \(\partial\Omega_D\):
      \begin{itemize}
         \item Compute the distance \(d_{\text{Dirichlet}}\) to the closest point on \(\partial\Omega_D\).
         \item Compute the distance \(d_{\text{Silhouette}}\) to the closest \emph{silhouette point} on \(\partial\Omega_N\).
         \item Let \(r := min(d_{\text{Dirichlet}},d_{\text{Silhouette}})\).
         \item Shoot a ray from \(\vec{x}_k\) in a random direction \(v\), letting the next point \(\vec{x}_{k+1}\) be the first point where the ray hits either (i) the sphere \(S(\vec{x}_k,r)\), or (ii) the Neumann boundary \(\partial\Omega_N\).
      \end{itemize}
   \item Add the value of \(g(\overline{\vec{x}}_k)\) to a running total \(\widehat{u}\).
\end{itemize}
   \item Return the estimate \(\widehat{u}/M\).
\end{itemize}

Here we've omitted a couple small but important details which we'll cover later---\eg{}, the ray \(\vec{v}\) must be sampled from a hemisphere rather than a sphere if \(\vec{x}_k\) is on the boundary, and we generally want to set some minimum radius \(r_{\min}\).  But our final implementation really won't be much more complicated than the short outline above.  The main thing you may notice is that we now have three geometric queries to implement: a \emph{closest point query}, a \emph{closest silhouette point query}, and a \emph{closest ray intersection}.  We'll first walk through how to implement these queries in Section~\ref{sec:GeometricQueries}, followed by a more detailed implementation of WoSt in Section~\ref{sec:WalkOnStars}.


\section{Geometric Queries}
\label{sec:GeometricQueries}

A wide variety of algorithms in visual, geometric, and scientific computing need to perform \emph{geometric queries}: given a piece of geometry (\eg{}, a polygon mesh or implicit surface), answer some question about this geometry, relative to a query point \(x\) (\eg{}, how far away is the closest point?).  Many of these queries are well-studied, with extremely efficient implementations available on a variety of platforms.  When the number of geometric primitives gets very large (\eg{}, thousands or millions of triangles), it becomes especially important to use a \emph{spatial data structure} like a bounding volume hierarchy (BVH) or binary space partition (BSP) to accelerate computation.  To keep things simple, we'll here just assume that the number of primitives is small, and check each primitive directly.  For an implementation-oriented introduction to spatial data structures, see \citet[Section 4.2]{pharr2016physically}.

\paragraph{Assumptions.} To keep our discussion (and our code) simple, we'll assume that the geometry of the domain \(\Omega\) is a collection of closed simple polygons in the 2D plane, possibly with holes.  More explicitly, we'll assume we're given two lists of polylines: one for the Dirichlet boundary, and one for the Neumann boundary.  Each polyline is given by a list of 2D points \(\vec{p}_1, \ldots, \vec{p}_m \in \mathbb{R}^2\), which are encoded via a \code{Vec2D} type with all the usual 2D vector operations.  We also assume that all polylines have a consistent winding direction---for instance, if the domain is the letter ``A'', then polylines around the outer boundary should go in counter-clockwise order, and polylines around the inner hole should go in clockwise order.  This final assumption will just make it easier to get a consistent normal direction, and to do inside-outside tests if needed.  In fact, most of these assumptions are not strictly required by the WoSt algorithm itself; they largely just make coding easier.  See especially \citet[Appendix B]{Sawhney:2023:WoSt} for handling of ``messier'' input geometry.

We'll break each query down into an ``atomic'' query for a single line segment, and a ``global'' query which basically just applies the atomic query to each segment in the overall list of polylines.

\subsection{Closest Ray Intersection}
\label{sec:ClosestRayIntersection}

\paragraph{Atomic.}

\paragraph{Global.}


\subsection{Closest Point Query}
\label{sec:ClosestPointQuery}

A \emph{closest point query} seeks the point closest to the geometry relative to a given query point \(\vec{x}\).  Although closest point queries sometimes come up in the context of signed distance fields, we won't need to worry about sign or orientation here: we simply want to find the closest point, full stop.

\begin{figure}[h!]
   \todo{A line segment and the closest points for a bunch of example query points.}
   \caption{Given a query point \(\vec{x}\), the closest point on a line segment between \(\vec{a}\) and \(\vec{b}\) can be at either an interior point or one of the endpoints.\label{fig:ClosestPointExamples}}
\end{figure}

\paragraph{Atomic.} Given a query point \(\vec{x}\), we want to find the closest point on a line segment with endpoints \(\vec{a}, \vec{b}\) (Figure~\ref{fig:ClosestPointExamples}).  To find this point, we could first find the closest point on the full line, check if it's inside the segment, and if not, take the closer of the two endpoints.  Fortunately, all these operations boil down to a very simple subroutine (\citet{Quilez:2020:SLS} gives a nice derivation):

\inputminted[firstline=36,lastline=41,bgcolor=bg]{cpp}{../code/WoStLaplace2D.cpp}

\paragraph{Global.} To find the distance from a query point \(x\) to a collection of polylines, we now just need to apply our atomic closest point query to all segments and keep the smallest distance:

\inputminted[firstline=63,lastline=73,bgcolor=bg]{cpp}{../code/WoStLaplace2D.cpp}
The function \(\code{length}\) computes the length of the given vector, and the constant \code{infinity} is equal to floating-point infinity (INF); as long as the polylines \code{P} contain at least one segment, the final distance \code{d} will be a finite value.

\subsection{Closest Silhouette Point Query}
\label{sec:ClosestSilhouettePointQuery}

\begin{figure}[h!]
   \todo{Diagram showing a pair of segments that are and are not a silhouette relative to the query point.}
   \caption{A point \(\vec{b}\) is a \emph{silhouette point} if the segments \(\vec{a}\vec{b}\) and \(\vec{b}\vec{c}\) are front- and back-facing relative to a point \(\vec{x}\), or vice-versa.}
\end{figure}

Silhouette points are points where geometry changes from front-facing to back-facing, relative to a query point \(\vec{x}\).  A \emph{closest silhouette point query} seeks the closest such point along the entire silhouette.  In general, queries of the visibility silhouette are far less common than closest ray or closest point queries---a good reference is the work on \emph{spatialized normal cone hierarchies (SNCH)} by \citet{johnson2001spatialized}; \citet[Section 5.1]{Sawhney:2023:WoSt} explains how to accelerate closest silhouette point queries using an SNCH.  Here we'll again just perform brute-force evaluation, rather than use an acceleration scheme.

\paragraph{Atomic.} Given a query point \(\vec{x}\), we want to determine whether the point \(\vec{b}\) on a connected pair of line segments \(\vec{a}\vec{b}\), \(\vec{b}\vec{c}\) is a silhouette point.  Equivalently, we want to know if \(\vec{x}\) is on opposite sides of these two segments (\eg{}, in front of \(\vec{a}\vec{b}\) and behind \(\vec{b}\vec{c}\)).  We can easily check which side of \(\vec{a}\vec{b}\) the point \(\vec{x}\) is on by just computing the determinant of the vectors \(\vec{u} := \vec{a}-\vec{x}\) and \(\vec{v} := \vec{b}-\vec{x}\).  Explicitly, \(\det(\vec{u},\vec{v}) = \vec{u}_1 \vec{v}_2 - \vec{u}_2 \vec{v}_1\).  Since this operation looks a lot like a cross product, we'll call it \code{cross} rather than \code{det} in our code (which also helps to distinguish it from \code{dot}!).  Our final routine is the quite simple:

\inputminted[firstline=43,lastline=46,bgcolor=bg]{cpp}{../code/WoStLaplace2D.cpp}

The logic here is simply that if \(\vec{x}\) is on the same side of both segments, then the determinants will have the same sign---hence their product will be positive.  Otherwise it will be negative.

\paragraph{Global.} To find the distance to the closest silhouette point we can once again iterate over all the geometry, check if each point is a silhouette point, and keep track of the closest distance seen so far:

\inputminted[firstline=75,lastline=86,bgcolor=bg]{cpp}{../code/WoStLaplace2D.cpp}
Note that in our code we check only the interior vertices of the polyline (by skipping the first and last index), since we assume that the domain boundary includes no open curves---hence the endpoint of any Neumann curve will be a Dirichlet point.  In general, however, one may want to generalize this code to handle open curves and closed pure-Neumann loops.


\subsection{Inside-Outside Test (optional)}
\label{sec:InsideOutsideTest}

\section{Walk on Stars}
\label{sec:WalkOnStars}

\bibliographystyle{plainnat}
\bibliography{WoSt-tutorial}

\end{document}
