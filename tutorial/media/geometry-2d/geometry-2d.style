canvas {
   width = 150
   height = 150
}

colors {
   color black = rgba(0,0,0,1)
   color white = rgba(1,1,1,1)
   color lightGray = rgba(0,0,0,.2)
   color darkBlue = #1b1f8a
}

global {
   scalar dotRadius = 2.0
   string labelSize = "12px"
   scalar lineWidth = 1.5
   scalar dotStroke = 1.0
   scalar padding = 1.0 -- amount of padding to prevent overlap
   scalar vectorLength = 25.0
   scalar minLength = .5 * canvas.width
}

-- Basic sets ------------------------------------------------------------------

forall Point p {

   p.x = (?,?) -- point location

   shape p.icon = Circle {
      fillColor: colors.black
      r: global.dotRadius
      center: p.x
   }
}

forall Point p
where p has label {
   p.labelText = Equation {
      string: p.label
      fontSize: global.labelSize
   }

   encourage near( p.icon, p.labelText )
}

forall Vector v {
   v.x = (?,?)
   v.v = (?,?)

   shape v.icon = Line {
      start: v.x
      end: v.x + global.vectorLength*unit(v.v)
      strokeColor: colors.darkBlue
      strokeWidth: global.lineWidth
      endArrowhead: "straight"
      endArrowheadSize: .5
   }
}

forall Vector v; Point p
where RootedAt(p,v) {
   override v.x = p.x
   layer p.icon above v.icon
}

forall Segment s {

   -- endpoints of the segment
   -- (may be overriden by later
   -- matches with specific data)
   vec2 s.x0 = (?,?)
   vec2 s.x1 = (?,?)

   -- by default, make sure that segments are not too short
   constraint s.lengthConstraint = ensure norm(s.x0-s.x1) > global.minLength

   shape s.icon = Line {
      start: s.x0
      end: s.x1
      strokeColor: colors.black
      strokeWidth: global.lineWidth
   }
}

forall Segment s; Point p; Point q
where s := LineSegment(p,q) {
   -- replace the endpoints with the
   -- locations of the given points
   override s.x0 = p.x
   override s.x1 = q.x
}

forall Segment s
where s has label {
   s.labelText = Equation {
      string: s.label
   }
   vec2 m = (s.x0 + s.x1)/2.
   scalar d = norm( m - s.labelText.center )
   encourage d == global.labelDistance
   ensure disjoint( s.labelText, s.icon, global.padding )
}

forall Segment t; Segment s; Point p
where t := ClosestSegment( s, p ) {
   override t.x0 = p.x
   override t.x1 = closestPoint( s.icon, p.x )
   override t.icon.strokeColor = colors.lightGray
}

forall Point q; Segment s; Point p
where q := ClosestPoint( s, p ) {
   override q.x = closestPoint( s.icon, p.x )
   override q.icon.fillColor = colors.white
   override q.icon.strokeColor = colors.black
   override q.icon.strokeWidth = global.dotStroke
}

forall Ray r {
   r.icon = Line {
      strokeColor: colors.lightGray
      style: "dashed"
      strokeDasharray: "4,4"
      ensureOnCanvas: false
   }
}

forall Ray r; Point p; Vector v
where r := RayFrom(p,v) {
   -- draw the ray as a line whose length
   -- is equal to the diameter of the canvas,
   -- so that it always goes "off screen" (but
   -- isn't so crazy long that it causes problems
   -- for display, editing, etc.)
   vec2 d = (canvas.width,canvas.height)
   scalar L = norm(d)
   vec2 u = unit(v.v)
   r.icon.start = p.x
   r.icon.end = p.x + L*u
}

forall Point q; Ray r; Point p; Vector v; Segment s; Point a; Point b
where q := RaySegmentIntersection(r,s); r := RayFrom(p,v); s := LineSegment(a,b) {

   -- put the intersection point at some random point in the segment
   scalar u = random(.2,.8)
   override q.x = (1-u)*a.x + u*b.x

   -- make the ray point toward the intersection point
   override v.v = unit(q.x - p.x)

   -- make the ray origin reasonably far from the intersection point
   ensure norm(p.x-q.x) > 1.5*global.vectorLength

   -- make sure the angle of intersection is not too shallow
   vec2 w = unit(b.x-a.x)
   ensure sqr(dot(v.v,w)) < .25

   -- draw the intersection point as a white dot
   override q.icon.fillColor = colors.white
   override q.icon.strokeColor = colors.black
   override q.icon.strokeWidth = global.dotStroke
}

forall Triangle t; Point p1; Point p2; Point p3
where t := Tri(p1, p2, p3)
{

   shape t.icon = Polygon {
      points: [ p1.x, p2.x, p3.x ]
   }
}

forall Point p; Triangle t; Point q0; Point q1; Point q2
where InTri( p, t ); t := Tri(q0, q1, q2) {
   override p.x = triangleRandom(q0.x, q1.x, q2.x)
}

forall Circle c {
   shape c.icon = Circle {
      center: (?,?)
      r: random(10,50)
      fillColor: none()
      strokeColor: colors.black
      strokeWidth: global.lineWidth
   }
}

forall Point p; Circle c
where OnCircle( p, c ) {
   override p.x = c.icon.r*circleRandom() + c.icon.center
}

forall Disk d {
   shape d.icon = Circle {
      center: (?,?)
      r: random(10,50)
   }
}

forall Point p; Disk d
where InDisk( p, d ) {
   override p.x = d.icon.r*diskRandom() + d.icon.center
}

forall Chord c {
   shape c.icon = Line {
      strokeWidth: .25*global.lineWidth
      strokeColor: colors.black
   }
}

forall Chord c; Disk d
where OfDisk(c,d) {
   scalar t0 = 2.*random(0,MathPI())
   scalar t1 = 2.*random(0,MathPI())
   c.icon.start = d.icon.r*(cos(t0),sin(t0)) + d.icon.center
   c.icon.end = d.icon.r*(cos(t1),sin(t1)) + d.icon.center
}

--- Overlap constraints --------------------------------------------------------

forall Set X
where X has label {
   ensure disjoint( X.icon, X.labelText, global.padding )
}

forall Set X; Set Y
where X has label {
   ensure disjoint( X.labelText, Y.icon, global.padding )
}

forall Set X; Set Y
where Y has label {
   ensure disjoint( X.icon, Y.labelText, global.padding )
}

forall Set X; Set Y
where X has label; Y has label {
   ensure disjoint( X.labelText, Y.labelText, global.padding )
}

--- Layering -------------------------------------------------------------------

forall Point p; Segment s {
   layer p.icon above s.icon
}

forall Point p; Ray r {
   layer p.icon above r.icon
}

