layout = [ shapeStage, labelStage ]

-- diagram dimensions (in px; multiply by 96/72 to convert to pt)
canvas {
   width = 306.66 -- ==230
   height = 200.00 -- ==150
}

--------------------------------------------------
-- Global constants ------------------------------
--------------------------------------------------

colors {
   color black = rgba(0,0,0,1)
   color white = rgba(1,1,1,1)
   color lightGray = rgba(.8,.8,.8,1)
   color clearGray = rgba(0,0,0,.2)
   color darkBlue = #1b1f8a
}

global {
   -- dot style
   color dotColor = colors.black
   scalar dotRadius = 1.75
   scalar dotStroke = .75

   -- line and arrow style
   scalar lineWidth = 1
   scalar arrowLength = 25.0

   -- label style
   string labelStyle = "italic"
   string labelFamily = "Linux Libertine"
   color labelColor = #000
   string labelSize = "13.3333px" -- equivalent to 10pt (multiply by 96/72)
   scalar labelDistance = 8.0

   -- layout parameters
   scalar padding = 2.0 -- amount of padding to prevent overlap
}

--------------------------------------------------
-- Points ----------------------------------------
--------------------------------------------------

forall Point p {

   -- location
   scalar p.x0 = ? in shapeStage
   scalar p.x1 = ? in shapeStage
   p.x = (p.x0,p.x1)

   shape p.icon = Circle {
      fillColor: global.dotColor
      r: global.dotRadius
      center: p.x
   }
}

forall Point p
where p has label {

   scalar theta = ? in labelStage
   scalar r = global.labelDistance

   p.labelText = Equation {
      center: p.x + r*(cos(theta),sin(theta))
      string: p.label
      fontSize: global.labelSize
      --fontStyle: global.labelStyle
      --fontFamily: global.labelFamily
      fillColor: global.labelColor
   }
   layer p.labelText above p.icon
}

--------------------------------------------------
-- Vectors ---------------------------------------
--------------------------------------------------

forall Vector v {

   -- vector origin
   scalar v.x0 = ? in shapeStage
   scalar v.x1 = ? in shapeStage
   v.x = (v.x0,v.x1)

   -- vector direction
   scalar v.v0 = ? in shapeStage
   scalar v.v1 = ? in shapeStage
   v.v = (v.v0,v.v1)

   shape v.icon = Line {
      start: v.x
      end: v.x + global.arrowLength*unit(v.v)
      strokeColor: colors.darkBlue
      strokeWidth: global.lineWidth
      endArrowhead: "straight"
      endArrowheadSize: .5
      fill: "none"
   }
}

forall Vector v
where v has label {

   scalar phi = ? in labelStage
   scalar theta = (MathPI()/2.)*cos(phi)
   vec2 w = unit(v.v)
   vec2 u = rotateBy( w, theta )
   scalar r = global.labelDistance

   v.labelText = Equation {
      string: v.label
      center: v.x + global.arrowLength*w + r*u
      fontSize: global.labelSize
      fillColor: global.labelColor
      --fontStyle: global.labelStyle
      --fontFamily: global.labelFamily
      ensureOnCanvas: false
   }
}

forall Vector v; Point p
where RootedAt(p,v) {
   override v.x = p.x
   layer p.icon above v.icon
}

-- draw segment normal as a vector at its midpoint
forall Vector v; Segment s
where v := Normal(s) {
   override v.x = (s.a + s.b)/2
   override v.v = global.arrowLength * rot90(unit(s.b - s.a))
}

--------------------------------------------------
-- Segments --------------------------------------
--------------------------------------------------

forall Segment s {

   -- first endpoint
   scalar a0 = ? in shapeStage
   scalar a1 = ? in shapeStage
   vec2 s.a = (a0,a1)

   -- second endpoint
   scalar b0 = ? in shapeStage
   scalar b1 = ? in shapeStage
   vec2 s.b = (b0,b1)

   shape s.icon = Line {
      start: s.a
      end: s.b
      strokeColor: colors.black
      strokeWidth: global.lineWidth
      fill: "none"
   }
}

forall Segment s; Point p; Point q
where s := LineSegment(p,q) {
   -- replace the endpoints with the
   -- locations of the given points
   override s.a = p.x
   override s.b = q.x
}

forall Segment s
where s has label {
   s.labelText = Equation {
      string: s.label
      fontSize: global.labelSize
      --fontStyle: global.labelStyle
      --fontFamily: global.labelFamily
      fillColor: global.labelColor
      ensureOnCanvas: false
   }
   layer s.labelText above s.icon

   vec2 m = (s.a + s.b)/2.
   scalar d = norm( m - s.labelText.center )
   encourage d == global.labelDistance in labelStage

   ensure disjoint( s.labelText, s.icon, global.padding ) in labelStage
}

forall Segment s
where isDashed( s ) {
   override s.icon.style = "dashed"
   override s.icon.strokeDasharray = "4,4"
}

--------------------------------------------------
-- Length markers --------------------------------
--------------------------------------------------

-- draw length markers as segments with perpendicular markers at the ends
forall Length l {

   -- marker parameters
   scalar l.markerSize = 2*global.dotRadius
   scalar l.shortening = 2*global.dotRadius

   -- first endpoint of labeled segment
   scalar a0 = ? in shapeStage
   scalar a1 = ? in shapeStage
   vec2 l.a = (a0,a1)

   -- second endpoint of labeled segment
   scalar b0 = ? in shapeStage
   scalar b1 = ? in shapeStage
   vec2 l.b = (b0,b1)

   vec2 l.t = unit( l.a - l.b ) -- tangent
   vec2 l.n = rot90( l.t ) -- normal

   -- offset length marker by +/- offset size
   scalar offsetSize = 8.0
   scalar l.h = ? in shapeStage
   ensure l.h*l.h == sqr(offsetSize) in shapeStage
   -- scalar l.h = 8

   -- endpoints of length marker
   scalar l.x = l.a - l.shortening*l.t + l.h*l.n
   scalar l.y = l.b + l.shortening*l.t + l.h*l.n

   l.icon = Line {
      start: l.x
      end: l.y
      strokeWidth: .75
      strokeColor: colors.lightGray
      fill: "none"
   }
   l.end0 = Line {
      start: l.x - l.markerSize*l.n
      end: l.x + l.markerSize*l.n
      strokeWidth: l.icon.strokeWidth
      strokeColor: l.icon.strokeColor
      fill: "none"
   }
   l.end1 = Line {
      start: l.y - l.markerSize*l.n
      end: l.y + l.markerSize*l.n
      strokeWidth: l.icon.strokeWidth
      strokeColor: l.icon.strokeColor
      fill: "none"
   }
}

forall Length l; Point a; Point b
where l := LengthBetween(a,b) {
   override l.a = a.x
   override l.b = b.x
}

forall Length l; Segment s
where l := LengthOf(s) {
   override l.a = s.a
   override l.b = s.b
   override l.icon.ensureOnCanvas = false
}

forall Length l
where l has label {

   -- offset label in same direction as length marker
   vec2 m = (l.x + l.y)/2.
   vec2 c = m + l.h*l.n/1.5

   l.labelText = Equation {
      center: c
      string: l.label
      fontSize: global.labelSize
      -- fontStyle: global.labelStyle
      -- fontFamily: global.labelFamily
      fillColor: l.icon.strokeColor
      ensureOnCanvas: false
   }
   layer l.labelText above l.icon
}

--------------------------------------------------
-- Triangles -------------------------------------
--------------------------------------------------

forall Triangle t; Point p1; Point p2; Point p3
where t := Tri(p1, p2, p3)
{
   shape t.icon = Polygon {
      points: [ p1.x, p2.x, p3.x ]
      fillColor: colors.clearGray
   }
}

forall Point p; Triangle t; Point q0; Point q1; Point q2
where InTri( p, t ); t := Tri(q0, q1, q2) {
   override p.x = triangleRandom(q0.x, q1.x, q2.x)
}


--------------------------------------------------
-- Polylines -------------------------------------
--------------------------------------------------

forall Polyline M {

   vec2 M.p0 = (? in shapeStage, ? in shapeStage)
   scalar theta0 = random(0,1)*2.*MathPI()
   scalar theta1 = theta0 + random(.5,1)*MathPI()/2
   scalar theta2 = theta1 + random(.5,1)*MathPI()/2
   scalar theta3 = theta2 - random(.5,1)*MathPI()/2
   scalar L = canvas.width/4
   vec2 M.p1 = M.p0 + L*(cos(theta0),sin(theta0))
   vec2 M.p2 = M.p1 + L*(cos(theta1),sin(theta1))
   vec2 M.p3 = M.p2 + L*(cos(theta2),sin(theta2))
   vec2 M.p4 = M.p3 + L*(cos(theta3),sin(theta3))

   shape M.icon = Polyline {
      points: [ M.p0, M.p1, M.p2, M.p3, M.p4 ]
   }
}

--------------------------------------------------
-- Circles ---------------------------------------
--------------------------------------------------

forall Circle c {
   -- center
   scalar x0 = ? in shapeStage
   scalar x1 = ? in shapeStage
   vec2 c.x = ( x0, x1 )

   -- radius
   scalar c.r = ? in shapeStage

   shape c.icon = Circle {
      center: c.x
      r: c.r
      fillColor: none()
      strokeColor: colors.black
      strokeWidth: global.lineWidth
   }
}

forall Point p; Circle c
where OnCircle( p, c ) {
   override p.x = c.icon.r*circleRandom() + c.icon.center
}

--------------------------------------------------
-- Disks -----------------------------------------
--------------------------------------------------

forall Disk d {
   -- center
   scalar x0 = ? in shapeStage
   scalar x1 = ? in shapeStage
   vec2 c.x = ( x0, x1 )

   -- radius
   scalar c.r = ? in shapeStage

   shape d.icon = Circle {
      center: c.x
      r: c.r
   }
}

forall Point p; Disk d
where InDisk( p, d ) {
   override p.x = d.icon.r*diskRandom() + d.icon.center
}

--------------------------------------------------
-- Chords ----------------------------------------
--------------------------------------------------

forall Chord c {
   shape c.icon = Line {
      strokeWidth: .25*global.lineWidth
      strokeColor: colors.black
      fill: "none"
   }
}

forall Chord c; Disk d
where OfDisk(c,d) {
   scalar t0 = 2.*random(0,MathPI())
   scalar t1 = 2.*random(0,MathPI())
   c.icon.start = d.icon.r*(cos(t0),sin(t0)) + d.icon.center
   c.icon.end = d.icon.r*(cos(t1),sin(t1)) + d.icon.center
}

--------------------------------------------------
-- Rays ------------------------------------------
--------------------------------------------------

forall Ray r {
   r.icon = Line {
      strokeColor: colors.lightGray
      style: "dashed"
      strokeDasharray: "4,4"
      ensureOnCanvas: false
      fill: "none"
   }
}

forall Ray r; Point p; Vector v
where r := RayFrom(p,v) {

   override v.x = p.x
   override v.icon.ensureOnCanvas = false

   -- draw the ray as a line whose length
   -- is equal to the diameter of the canvas,
   -- so that it always goes "off screen" (but
   -- isn't so crazy long that it causes problems
   -- for display, editing, etc.)
   vec2 d = (canvas.width,canvas.height)
   scalar L = norm(d)
   vec2 r.x = p.x
   vec2 r.v = unit(v.v)
   r.icon.start = r.x
   r.icon.end = r.x + L*r.v

   layer r.icon below v.icon
}

--------------------------------------------------
-- Ray intersections -----------------------------
--------------------------------------------------

forall Point q; Ray r; Point p; Vector v; Segment s; Point a; Point b
where q := RaySegmentIntersection(r,s); r := RayFrom(p,v); s := LineSegment(a,b) {

   -- put the intersection point at some random point in the segment
   scalar u = random(.2,.8)
   override q.x = (1-u)*a.x + u*b.x

   -- make the ray point toward the intersection point
   override v.v = unit(q.x - p.x)

   -- make the ray origin reasonably far from the intersection point
   ensure norm(p.x-q.x) > 1.5*global.arrowLength in shapeStage

   -- make sure the angle of intersection is not too shallow
   vec2 w = unit(b.x-a.x)
   ensure sqr(dot(v.v,w)) < .25 in shapeStage

   -- draw the intersection point as a white dot
   override q.icon.fillColor = colors.white
   override q.icon.strokeColor = colors.black
   override q.icon.strokeWidth = global.dotStroke
}

forall Point q; Ray r; Set s
where q := RayIntersection(r,s) {

   override q.x = rayIntersect( s.icon, r.x, r.v )

   -- since the intersection point could be off the
   -- canvas, we shouldn't try to enforce a constraint
   -- keeping it on the canvas
   override q.icon.ensureOnCanvas = false

   -- draw the intersection point as a white dot
   override q.icon.fillColor = colors.white
   override q.icon.strokeColor = colors.black
   override q.icon.strokeWidth = global.dotStroke
}


--------------------------------------------------
-- Closest points --------------------------------
--------------------------------------------------

forall Point q; Set s; Point p
where q := ClosestPoint( s, p ) {
   override q.x = closestPoint( s.icon, p.x )
   override q.icon.fillColor = colors.white
   override q.icon.strokeColor = colors.black
   override q.icon.strokeWidth = global.dotStroke
   override q.icon.ensureOnCanvas = false
}

forall Segment t; Set s; Point p
where t := ClosestSegment( s, p ) {
   override t.a = p.x
   override t.b = closestPoint( s.icon, p.x )
   override t.icon.strokeColor = colors.lightGray
   override t.icon.ensureOnCanvas = false
   override t.icon.strokeStyle = "dashed"
   override t.icon.strokeDasharray = "4,3"
}

--------------------------------------------------
-- Overlap constraints ---------------------------
--------------------------------------------------

forall Set X
where X has label {
   constraint X.labelDisjoint = ensure disjoint( X.icon, X.labelText, global.padding ) in labelStage
}

forall Length l {
   delete l.labelDisjoint
}

forall Set X; Set Y
where X has label {
   ensure disjoint( X.labelText, Y.icon, global.padding ) in labelStage
}

forall Set X; Set Y
where X has label; Y has label {
   ensure disjoint( X.labelText, Y.labelText, global.padding ) in labelStage
}

--------------------------------------------------
-- Layering --------------------------------------
--------------------------------------------------

forall Point p; Set X {
   layer p.icon above X.icon
}

forall Point p; Set X
where p has label {
   layer p.labelText above X.icon
}

-- AtomicClosestPoint.style ----------------------

-- forall Segment `ab` {
--    ensure norm( `ab`.a - `ab`.b ) == canvas.width in shapeStage
-- }
-- forall Segment `s` {
--    ensure norm( `s`.a - `s`.b ) == canvas.width * .5 in shapeStage
-- }
-- forall Length `l` {
--    ensure norm( `l`.a - `l`.b ) > canvas.width * .2 in shapeStage
--    ensure norm( `l`.a - `l`.b ) < canvas.width * .8 in shapeStage
-- }

-- ClosestPoint.style ----------------------------

-- forall Point xi; Point xj; Point yi; Point yj; Polyline M
-- where yi := ClosestPoint(M,xi); yj := ClosestPoint(M,xj) {
--    encourage 100/norm(xi.x-xj.x) == 0
-- }

-- FirstRay.style ----------------------------

-- forall Point p {
--    override p.x0 = -canvas.width/2 + 10
-- }
-- 
-- forall Point p; Polyline M {
-- 
--    scalar y0 = min( M.p0[1], min( M.p1[1], min( M.p2[1], min( M.p3[1], M.p4[1] ))))
--    scalar y1 = max( M.p0[1], max( M.p1[1], max( M.p2[1], max( M.p3[1], M.p4[1] ))))
-- 
--    scalar t = random(0,1)
--    override p.x1 = (1-t)*y0 + t*y1
-- }
-- 
-- forall Vector v {
--    override v.v0 = 1000
-- }

-- AtomicClosestSilhouette.style

forall Point `a` {
   scalar w = canvas.width
   scalar h = canvas.height
   override `a`.x = (-w/3,-h/4)
}
forall Point `b` {
   scalar w = canvas.width
   scalar h = canvas.height
   override `b`.x = (0,h/5)
}
forall Point `c` {
   scalar w = canvas.width
   scalar h = canvas.height
   override `c`.x = (w/3,-h/4)
}
forall Segment `ab` {
   override `ab`.icon.strokeWidth = 1.5*global.lineWidth
}
forall Segment `bc` {
   override `bc`.icon.strokeWidth = 1.5*global.lineWidth
}


