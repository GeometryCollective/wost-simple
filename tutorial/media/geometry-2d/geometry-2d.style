layout = [ shapeStage, labelStage ]

canvas {
   width = 150
   height = 150
}

--------------------------------------------------
-- Global constants ------------------------------
--------------------------------------------------

colors {
   color black = rgba(0,0,0,1)
   color white = rgba(1,1,1,1)
   color lightGray = rgba(.8,.8,.8,1)
   color darkBlue = #1b1f8a
}

global {
   -- dot style
   color dotColor = colors.black
   scalar dotRadius = 1.75
   scalar dotStroke = .75

   -- line and arrow style
   scalar lineWidth = 1
   scalar arrowLength = 25.0

   -- label style
   string labelStyle = "italic"
   string labelFamily = "Linux Libertine"
   color labelColor = #000
   string labelSize = "10px"
   scalar labelDistance = 8.0

   -- layout parameters
   scalar padding = 2.0 -- amount of padding to prevent overlap
}

--------------------------------------------------
-- Points ----------------------------------------
--------------------------------------------------

forall Point p {

   -- location
   scalar x0 = ? in shapeStage
   scalar x1 = ? in shapeStage
   p.x = (x0,x1)

   shape p.icon = Circle {
      fillColor: global.dotColor
      r: global.dotRadius
      center: p.x
   }
}

forall Point p
where p has label {
   p.labelText = Text {
      string: p.label
      fontSize: global.labelSize
      fontStyle: global.labelStyle
      fontFamily: global.labelFamily
      fillColor: global.labelColor
   }
   layer p.labelText above p.icon

   encourage near( p.icon, p.labelText ) in labelStage
}

--------------------------------------------------
-- Vectors ---------------------------------------
--------------------------------------------------

forall Vector v {

   -- vector origin
   scalar x0 = ? in shapeStage
   scalar x1 = ? in shapeStage
   v.x = (x0,x1)

   -- vector direction
   scalar v0 = ? in shapeStage
   scalar v1 = ? in shapeStage
   v.v = (v0,v1)

   shape v.icon = Line {
      start: v.x
      end: v.x + global.arrowLength*unit(v.v)
      strokeColor: colors.darkBlue
      strokeWidth: global.lineWidth
      endArrowhead: "straight"
      endArrowheadSize: .5
   }
}

forall Vector v; Point p
where RootedAt(p,v) {
   override v.x = p.x
   layer p.icon above v.icon
}

--------------------------------------------------
-- Segments --------------------------------------
--------------------------------------------------

forall Segment s {

   -- first endpoint
   scalar a0 = ? in shapeStage
   scalar a1 = ? in shapeStage
   vec2 s.a = (a0,a1)

   -- second endpoint
   scalar b0 = ? in shapeStage
   scalar b1 = ? in shapeStage
   vec2 s.b = (b0,b1)

   shape s.icon = Line {
      start: s.a
      end: s.b
      strokeColor: colors.black
      strokeWidth: global.lineWidth
   }
}

forall Segment s; Point p; Point q
where s := LineSegment(p,q) {
   -- replace the endpoints with the
   -- locations of the given points
   override s.a = p.x
   override s.b = q.x
}

forall Segment s
where s has label {
   s.labelText = Text {
      string: s.label
      fontSize: global.labelSize
      fontStyle: global.labelStyle
      fontFamily: global.labelFamily
      fillColor: global.labelColor
      ensureOnCanvas: false
   }
   layer s.labelText above s.icon

   vec2 m = (s.a + s.b)/2.
   scalar d = norm( m - s.labelText.center )
   encourage d == global.labelDistance in labelStage

   ensure disjoint( s.labelText, s.icon, global.padding ) in labelStage
}

--------------------------------------------------
-- Length markers --------------------------------
--------------------------------------------------

-- draw length markers as segments with perpendicular markers at the ends
forall Length l {

   -- marker parameters
   scalar l.markerSize = 2*global.dotRadius
   scalar l.shortening = 2*global.dotRadius

   -- first endpoint of labeled segment
   scalar a0 = ? in shapeStage
   scalar a1 = ? in shapeStage
   vec2 l.a = (a0,a1)

   -- second endpoint of labeled segment
   scalar b0 = ? in shapeStage
   scalar b1 = ? in shapeStage
   vec2 l.b = (b0,b1)

   vec2 l.t = unit( l.a - l.b ) -- tangent
   vec2 l.n = rot90( l.t ) -- normal

   -- offset length marker by +/- offset size
   -- scalar offsetSize = 8.0
   -- scalar h = ? in shapeStage
   -- ensure h*h == sqr(offsetSize) in shapeStage
   scalar h = 8

   -- endpoints of length marker
   scalar l.x = l.a - l.shortening*l.t + h*l.n
   scalar l.y = l.b + l.shortening*l.t + h*l.n

   l.icon = Line {
      start: l.x
      end: l.y
      strokeWidth: .75
      strokeColor: colors.lightGray
      fill: "none"
   }
   l.end0 = Line {
      start: l.x - l.markerSize*l.n
      end: l.x + l.markerSize*l.n
      strokeWidth: l.icon.strokeWidth
      strokeColor: l.icon.strokeColor
      fill: "none"
   }
   l.end1 = Line {
      start: l.y - l.markerSize*l.n
      end: l.y + l.markerSize*l.n
      strokeWidth: l.icon.strokeWidth
      strokeColor: l.icon.strokeColor
      fill: "none"
   }
}

forall Length l; Point a; Point b
where l := LengthBetween(a,b) {
   override l.a = a.x
   override l.b = b.x
}

forall Length l; Segment s
where l := LengthOf(s) {
   override l.a = s.a
   override l.b = s.b
   override l.icon.ensureOnCanvas = false
}

forall Length l
where l has label {
   l.labelText = Text {
      string: l.label
      fontSize: global.labelSize
      fontStyle: global.labelStyle
      fontFamily: global.labelFamily
      fillColor: l.icon.strokeColor
      ensureOnCanvas: false
   }
   layer l.labelText above l.icon

   vec2 m = (l.x + l.y)/2.
   scalar d = norm( m - l.labelText.center )
   encourage d == global.labelDistance in labelStage
}

--------------------------------------------------
-- Triangles -------------------------------------
--------------------------------------------------

forall Triangle t; Point p1; Point p2; Point p3
where t := Tri(p1, p2, p3)
{

   shape t.icon = Polygon {
      points: [ p1.x, p2.x, p3.x ]
   }
}

forall Point p; Triangle t; Point q0; Point q1; Point q2
where InTri( p, t ); t := Tri(q0, q1, q2) {
   override p.x = triangleRandom(q0.x, q1.x, q2.x)
}


--------------------------------------------------
-- Polylines -------------------------------------
--------------------------------------------------

forall Polyline M {

   vec2 M.p0 = (? in shapeStage, ? in shapeStage)
   vec2 M.p1 = (? in shapeStage, ? in shapeStage)
   vec2 M.p2 = (? in shapeStage, ? in shapeStage)
   vec2 M.p3 = (? in shapeStage, ? in shapeStage)
   vec2 M.p4 = (? in shapeStage, ? in shapeStage)

   shape M.icon = Polyline {
      points: [ M.p0, M.p1, M.p2, M.p3, M.p4 ]
   }
}

--------------------------------------------------
-- Circles ---------------------------------------
--------------------------------------------------

forall Circle c {
   -- center
   scalar x0 = ? in shapeStage
   scalar x1 = ? in shapeStage
   vec2 c.x = ( x0, x1 )

   -- radius
   scalar c.r = ? in shapeStage

   shape c.icon = Circle {
      center: c.x
      r: c.r
      fillColor: none()
      strokeColor: colors.black
      strokeWidth: global.lineWidth
   }
}

forall Point p; Circle c
where OnCircle( p, c ) {
   override p.x = c.icon.r*circleRandom() + c.icon.center
}

--------------------------------------------------
-- Disks -----------------------------------------
--------------------------------------------------

forall Disk d {
   -- center
   scalar x0 = ? in shapeStage
   scalar x1 = ? in shapeStage
   vec2 c.x = ( x0, x1 )

   -- radius
   scalar c.r = ? in shapeStage

   shape d.icon = Circle {
      center: c.x
      r: c.r
   }
}

forall Point p; Disk d
where InDisk( p, d ) {
   override p.x = d.icon.r*diskRandom() + d.icon.center
}

--------------------------------------------------
-- Chords ----------------------------------------
--------------------------------------------------

forall Chord c {
   shape c.icon = Line {
      strokeWidth: .25*global.lineWidth
      strokeColor: colors.black
   }
}

forall Chord c; Disk d
where OfDisk(c,d) {
   scalar t0 = 2.*random(0,MathPI())
   scalar t1 = 2.*random(0,MathPI())
   c.icon.start = d.icon.r*(cos(t0),sin(t0)) + d.icon.center
   c.icon.end = d.icon.r*(cos(t1),sin(t1)) + d.icon.center
}

--------------------------------------------------
-- Rays ------------------------------------------
--------------------------------------------------

forall Ray r {
   r.icon = Line {
      strokeColor: colors.lightGray
      style: "dashed"
      strokeDasharray: "4,4"
      ensureOnCanvas: false
   }
}

forall Ray r; Point p; Vector v
where r := RayFrom(p,v) {
   -- draw the ray as a line whose length
   -- is equal to the diameter of the canvas,
   -- so that it always goes "off screen" (but
   -- isn't so crazy long that it causes problems
   -- for display, editing, etc.)
   vec2 d = (canvas.width,canvas.height)
   scalar L = norm(d)
   vec2 u = unit(v.v)
   r.icon.start = p.x
   r.icon.end = p.x + L*u
}

--------------------------------------------------
-- Ray intersections -----------------------------
--------------------------------------------------

forall Point q; Ray r; Point p; Vector v; Segment s; Point a; Point b
where q := RaySegmentIntersection(r,s); r := RayFrom(p,v); s := LineSegment(a,b) {

   -- put the intersection point at some random point in the segment
   scalar u = random(.2,.8)
   override q.x = (1-u)*a.x + u*b.x

   -- make the ray point toward the intersection point
   override v.v = unit(q.x - p.x)

   -- make the ray origin reasonably far from the intersection point
   ensure norm(p.x-q.x) > 1.5*global.arrowLength in shapeStage

   -- make sure the angle of intersection is not too shallow
   vec2 w = unit(b.x-a.x)
   ensure sqr(dot(v.v,w)) < .25 in shapeStage

   -- draw the intersection point as a white dot
   override q.icon.fillColor = colors.white
   override q.icon.strokeColor = colors.black
   override q.icon.strokeWidth = global.dotStroke
}

--------------------------------------------------
-- Closest points --------------------------------
--------------------------------------------------

forall Point q; Set s; Point p
where q := ClosestPoint( s, p ) {
   override q.x = closestPoint( s.icon, p.x )
   override q.icon.fillColor = colors.white
   override q.icon.strokeColor = colors.black
   override q.icon.strokeWidth = global.dotStroke
   override q.icon.ensureOnCanvas = false
}

forall Segment t; Set s; Point p
where t := ClosestSegment( s, p ) {
   override t.a = p.x
   override t.b = closestPoint( s.icon, p.x )
   override t.icon.strokeColor = colors.lightGray
   override t.icon.ensureOnCanvas = false
   override t.icon.strokeStyle = "dashed"
   override t.icon.strokeDasharray = "4,3"
}

--------------------------------------------------
-- Overlap constraints ---------------------------
--------------------------------------------------

forall Set X
where X has label {
   ensure disjoint( X.icon, X.labelText, global.padding ) in labelStage
}

forall Set X; Set Y
where X has label {
   ensure disjoint( X.labelText, Y.icon, global.padding ) in labelStage
}

forall Set X; Set Y
where X has label; Y has label {
   ensure disjoint( X.labelText, Y.labelText, global.padding ) in labelStage
}

--------------------------------------------------
-- Layering --------------------------------------
--------------------------------------------------

forall Point p; Segment s {
   layer p.icon above s.icon
}

forall Point p; Ray r {
   layer p.icon above r.icon
}

forall Point p; Point q
where p has label {
   layer p.labelText above q.icon
}

-- AtomicClosestPoint.substance ------------------

forall Segment `ab` {
   ensure norm( `ab`.a - `ab`.b ) == canvas.width in shapeStage
}
forall Segment `s` {
   ensure norm( `s`.a - `s`.b ) == canvas.width * .5 in shapeStage
}
forall Length `l` {
   ensure norm( `l`.a - `l`.b ) > canvas.width * .2 in shapeStage
   ensure norm( `l`.a - `l`.b ) < canvas.width * .8 in shapeStage
}

